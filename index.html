<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Coming+Soon&display=swap" rel="stylesheet">
  <title>Wordsearch Puzzle</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }

    #grid {
      display: grid;
      grid-gap: 2px;
      justify-content: center;
      margin: 20px 0;
    }

    .cell {
      width: 30px;
      height: 30px;
      background-color: #eee;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      font-weight: bold;
      user-select: none;
    }

    .selected {
      background-color: #add8e6;
    }

    .found {
      background-color: #90ee90;
    }

    #word-list {
      margin-bottom: 10px;
    }

    .found-word {
      text-decoration: line-through;
      color: gray;
    }

    #wordsearch-app {
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
        border: 4px solid #ccc;
        border-radius: 16px;
        background-color: #fafafa;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    #controls {
        margin-bottom: 10px;
    }

    #puzzle-fact {
        margin-top: 20px;
        padding: 12px;
        border-radius: 10px;
        background-color: #fff8e1;
        color: #5c4033;
        font-style: normal;
        font-size: 1em;
        font-family: 'Coming Soon', cursive;
        box-shadow: inset 0 0 4px rgba(0,0,0,0.05);
        border: 2px dashed #e0c080;
    }

    #congrats-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 8px 16px;
        border-radius: 12px;
        font-size: 1em;
        font-weight: bold;
        color: #4b0082;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
        z-index: 10;
        pointer-events: none;
        text-align: center;
        white-space: nowrap;         /* üí• Force single line */
        max-width: none;             /* üí• Don‚Äôt cap the width */
    }

    @keyframes pop {
        0% { transform: scale(0.6); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
    }

    #wordsearch-app h1 {
        font-family: 'Segoe UI', 'Quicksand', 'Comic Neue', sans-serif;
        font-size: 2.5em;
        font-weight: 700;
        color: #ab84d8; /* soft purple */
        text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.6);
        margin-bottom: 20px;
        text-align: center;
    }

    @keyframes shine {
        0% { background-position: 0% }
        100% { background-position: 100% }
    }

    #rainbow-title {
        margin-bottom: 20px;
        text-align: center;
        font-family: 'Segoe UI', 'Quicksand', 'Comic Neue', sans-serif;
        line-height: 1.2;
    }

    #wordling-row {
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 6px;
        flex-wrap: wrap;
        margin-top: 20px;
    }

        .wordling-row-img {
        width: 48px;
        height: auto;
        animation: pop-in 0.4s ease;
        user-select: none;
    }

    #hidden-word {
        text-align: center;
        color: #444;
        font-size: 1em;
    }

    @media (max-width: 600px) {
      #grid {
        font-size: 1.4em;
        gap: 4px;
      }
      .cell {
        width: 32px;
        height: 32px;
      }
      select,
      button {
        font-size: 1.2em;
        padding: 10px 16px;
        border-radius: 8px;
      }
      #wordlist-select, #size-select {
        width: 100%;
        margin-bottom: 10px;
      }
      #wordling-row {
        overflow-x: auto;
        white-space: nowrap;
        justify-content: flex-start;
        padding: 10px 6px;
        scroll-snap-type: x mandatory;
      }
      
      .wordling-row-img {
        scroll-snap-align: center;
      }
    }
  </style>

</head>

<body>
    <div id="wordsearch-app">
        <h1 id="rainbow-title"></h1>
    
        <div id="controls">
            <label for="size-select">Grid Size:</label>
            <select id="size-select">
                <option value="8">8√ó8</option>
                <option value="10" selected>10√ó10</option>
                <option value="12">12√ó12</option>
            </select>
    
            <label for="wordlist-select" style="margin-left: 10px;">Word List:</label>
            <select id="wordlist-select">
                <option value="fruits">üçì Fruits</option>
                <option value="animals">üêØ Animals</option>
                <option value="cozy">üî• Cozy Words</option>
                <option value="gemstones">üíé Gemstones</option>
            </select>
    
            <button id="new-game-btn" style="margin-left: 10px;">New Puzzle</button>
        </div>
    
        <div id="word-list"></div>
        <div id="hidden-word" style="margin-top: 10px; font-style: italic;">
            <strong>Hidden Word:</strong> <span id="hidden-word-value">(still hiding...)</span>
        </div>
    
        <div id="grid-container" style="position: relative; display: inline-block;">
            <div id="grid"></div>
            <div id="congrats-overlay" style="display: none;">
                üåü Puzzle Complete! üåü
            </div>
        </div>
        
        <div id="puzzle-fact"></div>

        <div id="wordling-row" style="margin-top: 20px;"></div>
        <div id="korok-stats" style="margin-top: 10px; font-size: 0.9em; color: #4b0082;">
            üåø Wordlings found: <span id="korok-count">0</span>
        </div>
    </div>

    

    <script>
        const wordLists = {
            fruits: {
                words: ['APPLE', 'BANANA', 'ORANGE', 'KIWI', 'MANGO', 'GRAPE', 'PEAR', 'MELON', 'CHERRY', 'LEMON'],
                facts: [
                    "Bananas are technically berries, but strawberries aren't!",
                    "Oranges were once considered a luxury item in Europe.",
                    "Apples float because they're 25% air!",
                    "Kiwi fruit was originally called the 'Chinese gooseberry.'",
                    "Grapes explode in the microwave -- please don't try it.",
                    "Cherries are part of the rose family!",
                    "Pear trees can live over 100 years."
                ]
            },
            animals: {
                words: ['CAT', 'DOG', 'PANDA', 'KOALA', 'BUNNY', 'FOX', 'FAWN', 'HEDGEHOG', 'OTTER', 'SLOTH'],
                facts: [
                    "Otters hold hands while sleeping to stay together.",
                    "Koalas have unique fingerprints ‚Äî just like humans!",
                    "Sloths can hold their breath longer than dolphins.",
                    "Hedgehogs were once called 'urchins' in Old English.",
                    "A panda‚Äôs diet is 99% bamboo, but they have carnivore teeth.",
                    "Foxes can make over 40 different vocal sounds.",
                    "Fawns can stand and walk within minutes of birth."
                ]
            },
            cozy: {
                words: ['TEA', 'BLANKET', 'FIREPLACE', 'BOOK', 'CANDLE', 'WINDOW', 'SOCKS', 'COCOA', 'QUILT', 'SLIPPERS'],
                facts: [
                    "Candles were once made from animal fat or beeswax.",
                    "Reading by firelight was considered a luxury before electricity.",
                    "The oldest known quilt dates back to around 3400 BC.",
                    "Slippers were invented in China over 5,000 years ago.",
                    "In the 1800s, tea was locked in a tea caddy with a key.",
                    "Wool socks have natural antibacterial properties!",
                ]
            },
            gemstones: {
                words: ['AGATE', 'ALEXANDRITE', 'AMBER', 'AMETHYST', 'APATITE', 'BERYL', 'CHALCEDONY', 'CITRINE', 'CORUNDUM', 'DIAMOND', 'EMERALD', 'GARNET', 'ONYX', 'OPAL', 'PEARL', 'PERIDOT', 'QUARTZ', 'ROSE QUARTZ', 'RUBY', 'SAPPHIRE', 'TOPAZ', 'TOURMALINE', 'TURQUOISE', 'ZIRCON'],
                facts: [
                    "The only 'precious' gemstones are diamond, ruby, sapphire, and emerald.",
                    "Although amber is considered a gemstone, it's an organic material rather than inorganic.",
                    "Amber is fossilized tree resin and may contain inclusions of plants or small animals.",
                    "Amethyst is purple due to the irradiation of iron impurities in its matrix.",
                    "Apatite is the same mineral that comprises human teeth.",
                    "Diamond is the hardest pure element.",
                    "Pure diamond is colorless, but impurities can make a diamond blue, brown, or other colors.",
                    "Garnet occurs in all colors, but blue garnets are extremely rare.",
                    "Garnets are not traditionally a precious gem, but a tsavorite garnet can be more expensive than an emerald.",
                    "Opals may contain anywhere from 3% to 21% water by weight.",
                    "Opal is amorphous and does not have a crystal structure.",
                    "Pearls are produced by the tissue of a mollusk.",
                    "Peridot is the name given to gem-quality olivine.",
                    "Peridot gets its green color from iron.",
                    "Translucent gemstone-quality quartz is named by its color, such as amethyst (purple) or citrine (yellow).",
                    "Pure quartz is also known as rock crystal.",
                    "Both rubies and sapphires are the same mineral: corundum.",
                ],
            }
        };

        const wordlingThemes = {
            fruits: ['wordling1.png', 'wordling2.png', 'wordling3.png', 'wordling4.png'],
            animals: ['wordling1.png', 'wordling2.png', 'wordling3.png', 'wordling4.png'],
            cozy: ['cozy-wordling1.png', 'cozy-wordling2.png'], // reuse is fine!
            gemstones: ['gem-wordling1.png', 'gem-wordling2.png', 'gem-wordling3.png', 'gem-wordling4.png']
            // add more as you build more puzzles
        };

        const grid = [];
        let gridSize = 10;
        let words = [];
        let currentPuzzleTheme = 'fruits'; // default
        let bonusWord = ''; // The hidden word
        let korokCount = 0;
        const cellElements = [];
        const directions = [
            [0, 1], [1, 0], [1, 1], [-1, 1]
        ];
        let selectedCells = [];
        let isMouseDown = false;
        let selecting = false;
  
        function createEmptyGrid() {
            for (let i = 0; i < gridSize; i++) {
                grid[i] = [];
                cellElements[i] = [];
                for (let j = 0; j < gridSize; j++) {
                grid[i][j] = '';
                cellElements[i][j] = null;
                }
            }
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function getCellData(el) {
            return {
                element: el,
                letter: el.textContent,
                row: parseInt(el.dataset.row),
                col: parseInt(el.dataset.col)
            };
        }

        function tryPlacingWords(wordList, maxWords = 12) {
            const placed = [];
            const copy = [...wordList];
            shuffle(copy);

            for (let originalWord of copy) {
                const cleanWord = originalWord.replace(/\s+/g, '').toUpperCase();

                if (cleanWord.length > gridSize) continue; // skip overly long words

                if (placed.length >= maxWords) break;

                if (placeWord(cleanWord)) {
                placed.push({ display: originalWord, value: cleanWord });
                }
            }

            // Add a hidden bonus word!
            const allWords = wordList.filter(w => !placed.some(p => p.display === w));
            const hidden = allWords[Math.floor(Math.random() * allWords.length)];
            bonusWord = hidden.replace(/\s+/g, '').toUpperCase();
            placeWord(bonusWord); // placed but not shown!

            return placed;
        }

        function applyRainbowTitle(text) {
            const colors = ['#f8b3da', '#b3e5fc', '#d2f8b3', '#ffd59e', '#e0bbf9', '#fcd5ce', '#c7f9cc'];
            const container = document.getElementById('rainbow-title');
            container.innerHTML = '';

            for (let i = 0; i < text.length; i++) {
                const span = document.createElement('span');
                span.textContent = text[i];
                span.style.color = colors[i % colors.length];
                span.style.fontWeight = '700';
                span.style.fontSize = '1.5em';
                span.style.marginRight = '1px';
                span.style.display = 'inline-block';
                span.style.transform = 'translateY(1px)';
                container.appendChild(span);
            }
        }

        applyRainbowTitle("Wordsearch");

        function generatePuzzle() {
            const sizeValue = document.getElementById('size-select').value;
            const listValue = document.getElementById('wordlist-select').value;
            currentPuzzleTheme = listValue; // store the theme globally
            const wordListObj = wordLists[listValue];

            const wordList = wordListObj.words;
            const facts = wordListObj.facts;

            const randomFact = facts[Math.floor(Math.random() * facts.length)];
            document.getElementById('puzzle-fact').textContent = `${randomFact}`;

            gridSize = parseInt(sizeValue);

            selectedCells = [];
            selectedCells.direction = null;

            createEmptyGrid();
            const maxWords = Math.floor(gridSize * 0.8); // scale with grid size
            words = tryPlacingWords(wordList, maxWords);
            fillEmptyCells();
            renderWordList();
            renderGrid();
        }
  
        function placeWord(word) {
            for (let attempts = 0; attempts < 100; attempts++) {
                const dir = directions[Math.floor(Math.random() * directions.length)];
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
        
                let fits = true;
                for (let i = 0; i < word.length; i++) {
                const r = row + dir[0] * i;
                const c = col + dir[1] * i;
                if (r < 0 || r >= gridSize || c < 0 || c >= gridSize || (grid[r][c] && grid[r][c] !== word[i])) {
                    fits = false;
                    break;
                }
                }
        
                if (fits) {
                for (let i = 0; i < word.length; i++) {
                    const r = row + dir[0] * i;
                    const c = col + dir[1] * i;
                    grid[r][c] = word[i];
                }
                return true;
                }
            }
            return false;
        }
  
        function fillEmptyCells() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                if (!grid[i][j]) {
                    grid[i][j] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }
        }
  
        function renderWordList() {
            const listDiv = document.getElementById('word-list');
            listDiv.innerHTML = '<strong>Find these words:</strong><br>' +
                words.map(w => `<span id="word-${w.value}">${w.display}</span>`).join(', ');
        }
  
        function renderGrid() {
            const gridDiv = document.getElementById('grid');
            gridDiv.innerHTML = '';
            gridDiv.style.gridTemplateColumns = `repeat(${gridSize}, 30px)`; // <-- this fixes it!

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                const cell = document.createElement('div');
                cell.textContent = grid[i][j];
                cell.className = 'cell';
                cell.dataset.row = i;
                cell.dataset.col = j;

                cell.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    clearSelection();
                    selectCell(cell);
                });

                cell.addEventListener('mouseenter', () => {
                    if (isMouseDown) selectCell(cell);
                });

                cell.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    checkSelectedWord();
                });

                cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                cell.addEventListener('touchend', handleTouchEnd);

                gridDiv.appendChild(cell);
                cellElements[i][j] = cell;
                }
            }

            document.body.addEventListener('mouseup', () => {
                isMouseDown = false;
                checkSelectedWord();
            });
        }

        function handleTouchStart(e) {
          e.preventDefault();
          const target = e.target.closest('.cell');
          if (target) {
            selecting = true;
            clearSelection(); // üî• reset any previous selection
            selectCell(target);
          }
        }

        function handleTouchMove(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const target = document.elementFromPoint(touch.clientX, touch.clientY);
          if (target && target.classList.contains('cell') && selecting) {
            selectCell(target); // üî• Use your core function!
          }
        }

        function handleTouchEnd(e) {
          if (selecting) {
            selecting = false;
            checkSelectedWord();
            clearHighlights();
            selectedCells = [];
          }
        }
  
        function selectCell(cell) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            const last = selectedCells[selectedCells.length - 1];

            // Start with first cell
            if (!last) {
                cell.classList.add('selected');
                selectedCells.push({ row, col, letter: grid[row][col], element: cell });
                return;
            }

            // Undo/backtrack if dragging over previous cell
            if (
                selectedCells.length > 1 &&
                row === selectedCells[selectedCells.length - 2].row &&
                col === selectedCells[selectedCells.length - 2].col
            ) {
                last.element.classList.remove('selected');
                selectedCells.pop();
                return;
            }

            // Already selected elsewhere: ignore
            if (selectedCells.some(c => c.row === row && c.col === col)) return;

            // Lock direction from first two cells
            if (selectedCells.length === 1) {
                const dRow = row - last.row;
                const dCol = col - last.col;
                if ((dRow === 0 && dCol === 0) || Math.abs(dRow) > 1 || Math.abs(dCol) > 1) return;

                selectedCells.direction = [dRow, dCol];
            } else if (selectedCells.direction) {
                // Allow small error margin for direction
                const expectedRow = last.row + selectedCells.direction[0];
                const expectedCol = last.col + selectedCells.direction[1];

                const rowDiff = Math.abs(expectedRow - row);
                const colDiff = Math.abs(expectedCol - col);

                if (rowDiff > 0.2 || colDiff > 0.2) return; // allow slight error
            }

            // Add cell
            cell.classList.add('selected');
            selectedCells.push({ row, col, letter: grid[row][col], element: cell });
        }
        
        function clearSelection() {
            selectedCells.forEach(c => c.element.classList.remove('selected'));
            selectedCells = [];
            selectedCells.direction = null; // Reset direction
        }

        function getRandomPastel() {
            const hue = Math.floor(Math.random() * 360);
            return `hsl(${hue}, 70%, 85%)`; // pastel-like
        }

        function createImageWordling(size = 48, theme = 'fruits') {
            const army = wordlingThemes[theme] || ['wordling1.png'];
            const chosen = army[Math.floor(Math.random() * army.length)];

            const img = document.createElement('img');
            img.src = `images/${chosen}`;
            img.alt = 'Wordling';
            img.className = 'wordling-img';
            img.style.width = `${size}px`;
            return img;
        }

        function showKorok() {
            korokCount++;
            document.getElementById('korok-count').textContent = korokCount;
            document.getElementById('hidden-word-value').textContent = bonusWord;

            const armyRow = document.getElementById('wordling-row');
            const mini = createImageWordling(48, currentPuzzleTheme);
            mini.classList.add('wordling-row-img');

            // Alternate placement: add to start or end
            if (korokCount % 2 === 0) {
                armyRow.insertBefore(mini, armyRow.firstChild);
            } else {
                armyRow.appendChild(mini);
            }
        }
  
        function checkSelectedWord() {
            if (selectedCells.length === 0) return;
            const word = selectedCells.map(c => c.letter).join('');
            const reversed = word.split('').reverse().join('');

            const match = words.find(w => w.value === word || w.value === reversed);
            const isBonus = word === bonusWord || reversed === bonusWord;

            if (match || isBonus) {
                const pastel = getRandomPastel();
                selectedCells.forEach(c => {
                    c.element.style.backgroundColor = pastel;
                    c.element.classList.add('found');
                });

                if (match) {
                    document.getElementById(`word-${match.value}`).classList.add('found-word');
                }

                if (isBonus) {
                    showKorok();
                }

                checkIfPuzzleComplete();
            }

            clearSelection();
        }
        

        function checkIfPuzzleComplete() {
            const found = document.querySelectorAll('.found-word').length;
            if (found === words.length) {
                document.getElementById('congrats-overlay').style.display = 'flex';
                launchConfetti(); // üéâ Right here!
                setTimeout(() => {
                    document.getElementById('congrats-overlay').style.display = 'none';
                }, 1500);
            }
        }

        function launchConfetti() {
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { x: 0.5, y: 0.5 }
            });
        }
  
        // Run the game
        document.getElementById('new-game-btn').addEventListener('click', generatePuzzle);
        generatePuzzle(); // initial load
    
    </script>
</body>
</html>
